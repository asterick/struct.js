/**
 ** Structure handler for javascript
 **/

main
	= _ structure:top_level
{
	var bottomup = structure.packing === "bottom",
		tdv = new DataView(new ArrayBuffer(8));

	// This is currently only little endian
	function readBits(little, bits, byteAddress, bitOffset) {
		var ba = byteAddress,
			o = ["var v = 0;"],
			q = 8 - bitOffset;

		function top(bits) {
			var o = "this.$u8[" + ba + "] >>" + (8 - bits);

			return o;
		}

		function bottom(bits) {
			var o = "this.$u8[" + ba + "] & " + ((1 << bits) - 1);

			return o;
		}

		function shift(s, a) {
			if (a == 0) return s;
			return "(" + s + ") << " + a;
		}

		// If we can pack this into one byte
		if (q >= bits) {
			var m = (1 << bits) - 1,
				s = bottomup ? bitOffset : (8 - bitOffset - bits);

			o.push("v = (this.$u8[" + ba + "] >> ", s, ") & ", m, ";");
		} else if (little) {
			var l = bits,
				s = 0;
				
			if (bitOffset) {
				s = q;
				o.push("v = ", (bottomup ? top : bottom)(q), ";");
				l -= s;
				ba++;
			}

			while (l >= 8) {
				o.push("v |= ", shift("this.$u8[" + (ba++) + "]", s), ";");
				s += 8;
				l -= 8;
			}

			if (l > 0) {
				o.push("v |= ", shift((bottomup ? bottom : top)(l),s), ";");
			}
		} else {
			var s = bits,
				l = bits;

			if (bitOffset) {
				s -= q;
				o.push("v = ", shift((bottomup ? top : bottom)(q),s), ";");
				l -= q;
				ba++;
			}

			while (l >= 8) {
				s -= 8;
				l -= 8;
				o.push("v |= this.$u8[", ba++, "] << ", s, ";");
			}

			if (l > 0) {
				o.push("v |= ", (bottomup ? bottom : top)(l), ";");
			}
		}

		return o.join('');
	}

	// This is currently only little endian
	function writeBits(little, bits, byteAddress, bitOffset) {
		var mask = (bits == 32) ? 0xFFFFFFFF : ((1 << bits) - 1),
			ba = byteAddress,
			o = [],
			q = 8 - bitOffset;

		function top(bits, v) {
			var mask = 0xFF >> bits;

			return "(this.$u8[" + ba + "] & " + mask + ") | "
				 + "((" + v + " << " + (8-bits) + ") & " + ~mask + ");";
		}

		function bottom(bits, v) {
			var mask = (0xFF << bits) & 0xFF;

			return "(this.$u8[" + ba + "] & " + mask + ") | (" + v + " & " + ~mask + ");";
		}

		function shift(v, a) {
			if (a) { return "(" + v + " >> " + a + ")"; }
			return v;
		}

		if (q >= bits) {
			var s = bottomup ? bitOffset : (8 - bitOffset - bits),
				m = ((1 << bits) - 1) << s;

			o.push("this.$u8[" + ba + "]  = (this.$u8[" + ba + "] & ", ~m, ") | ((v << ",s,") & ", m,");");
		} else if (little) {
			var l = bits,
				s = 0;

			if (bitOffset) {
				o.push("this.$u8[",ba,"] = ", (bottomup ? top : bottom)(q, "v"));
				s = q;
				l -= s;
				ba++;
			}

			while (l >= 8) {
				o.push("this.$u8[",ba++,"] = v >> ", s, ";");
				s += 8;
				l -= 8;
			}

			if (l > 0) {
				o.push("this.$u8[",ba,"] = ", (bottomup ? bottom : top)(l, shift("v", s)));
			}
		} else {
			var l = bits,
				s = bits;

			if (bitOffset) {
				l -= q;
				s -= q;

				o.push("this.$u8[",ba,"] = ", (bottomup ? top : bottom)(q, shift("v", s)));

				ba++;
			}

			while (l >= 8) {
				s -= 8;
				l -= 8;
				o.push("this.$u8[", ba++, "] = v >> ", s, ";");
			}

			if (l > 0) {
				t = (1 << l) - 1;
				o.push("this.$u8[",ba,"] = ", (bottomup ? bottom : top)(l, "v"));
			}
		}
	
		return o.join('');
	}

	function unsigned(little, bits, byteAddress, bitOffset) {
		var r = readBits(little, bits, byteAddress, bitOffset),
			w = writeBits(little, bits, byteAddress, bitOffset);

		if (bits === 32) {
			r += "return (v & 0x80000000) ? (v + 0x100000000) : v;";
		} else {
			r += "return v;"
		}

		return {
			get: new Function(r),
			set: new Function("v", w)
		};
	}

	function signed(little, bits, byteAddress, bitOffset) {
		var r = readBits(little, bits, byteAddress, bitOffset),
			w = writeBits(little, bits, byteAddress, bitOffset);

		if (bits !== 32) {
		 	r += "return v << " + (32 - bits) + " >> " + (32 - bits) + ";";
		} else {
			r += "return v;";
		}

		return {
			get: new Function(r),
			set: new Function("v", w)
		};
	}

	function float(little, bits, byteAddress, bitOffset) {
		if (!bitOffset) {
			switch (bits) {
			case 32:
				return {
					get: function () { return this.$dv.getFloat32(byteAddress, little); },
					set: function (v) { this.$dv.setFloat32(byteAddress, v, little); }
				}
			case 64:
				return {
					get: function () { return this.$dv.getFloat64(byteAddress, little); },
					set: function (v) { this.$dv.setFloat64(byteAddress, v, little); }
				}
			}
		}

		var rl, rh, wl, wh; 
		
		if (little || bits != 64) {
			rl = readBits(little, 32, byteAddress, bitOffset),
			wl = writeBits(little, 32, byteAddress, bitOffset),
			rh = readBits(little, 32, byteAddress + 4, bitOffset), 
			wh = writeBits(little, 32, byteAddress + 4, bitOffset);
		} else {
			rh = readBits(little, 32, byteAddress, bitOffset),
			wh = writeBits(little, 32, byteAddress, bitOffset),
			rl = readBits(little, 32, byteAddress + 4, bitOffset), 
			wl = writeBits(little, 32, byteAddress + 4, bitOffset);
		}

		switch (bits) {
			case 32:
				return {
					get: new Function(rl + "this._tdv.setUint32(0, v); return this._tdv.getFloat32(0)"),
					set: new Function("v", "this._tdv.setFloat32(0, v); v = this._tdv.getUint32(0);" + wl)
				};
			case 64:
				return {
					get: new Function(rh + "this._tdv.setUint32(0, v);" + rl + "this._tdv.setUint32(4, v);" + "return this._tdv.getFloat64(0)"),
					set: new Function("v", "this._tdv.setFloat64(0, v); v = this._tdv.getUint32(0);" + wh + "v = this._tdv.getUint32(4);" + wl)
				};
		}
	}

	// === Prototype generators ========
	function globals() {
		var proto = {};

		Object.defineProperties(proto, {
			_tdv: { value: tdv }
		});

		return proto;
	}

	function isSimple(field) {
		switch (field.type) {
		case 'unsigned':
		case 'signed':
		case 'float':
			return true;
		}
		return false;
	}

	function accessor(accessors, field, offset, index) {
		var byteAddr = Math.floor(offset / 8),
			bitAddr = offset % 8,
			def, simple;

		switch (field.type) {
		case 'unsigned':
			def = unsigned(field.endian === "little", field.size, byteAddr, bitAddr);
			simple = true;
			break ;
		case 'signed':
			def = signed(field.endian === "little", field.size, byteAddr, bitAddr);
			simple = true;
			break ;
		case 'float':
			def = float(field.endian === "little", field.size, byteAddr, bitAddr);
			simple = true;
			break ;
		case 'struct':
			def = { writable: true, value: struct(field, offset) };
			simple = false;
			break ;
		case 'array':
			def = { writable: true, value: array(field, offset) };
			simple = false;
			break ;
		case 'void':
			return true;
		default:
			throw new Error("Unknown filed type: " + field.type);
		}

		Object.defineProperty(accessors, (index !== undefined) ? index : field.name, def);
		return simple;
	}

	function struct(field, offset) {
		var accessors = globals(),
			chain = ["this.$u8 = u8; this.$dv = dv;"];

		field.fields.forEach(function (field) {
			var simple = accessor(accessors, field, field.offset + offset);

			if (!simple) { chain.push("this.", field.name, " = new this.", field.name, "(u8,dv);"); }
		});

		Object.defineProperty(accessors, "_size", { value: Math.ceil(field.size / 8) });

		var f = new Function("u8", "dv", chain.join(""))
		f.prototype = accessors;

		return f;
	}

	function array(field, offset) {
		var accessors = globals(),
			chain = ["this.$u8 = u8; this.$dv = dv;"];

		for (var i = 0; i < field.count; i++) {
			var simple = accessor(accessors, field.field, offset + field.field.size * i, i);

			if (!simple) { chain.push("this[", i, "] = new this[", i, "](u8,dv);"); }
		}

		var f = new Function("u8", "dv", chain.join(""))
		f.prototype = accessors;

		Object.defineProperty(accessors, "_size", { value: Math.ceil(field.field.size * field.count / 8) });

		return f;
	}

	// Create constructor
	var tlc = struct(structure, 0),
		bytes = Math.ceil(structure.size / 8);

	return function (data) {
		if (!data) {
			data = new ArrayBuffer(bytes);
		} else if (data.byteLength < bytes) {
			throw new Error("ArrayBuffer is below minimum length");
		}

		var u8 = new Uint8Array(data),
			dv = new DataView(data),
			s = new tlc(u8, dv);

		s._data = data;

		return s;
	};
}

/**
 ** Grammar here
 **/

top_level
	= p:packing f:fieldset
		{ return { packing: p, fields: f, size: f.size }; }

packing
	= "top"i _
		{ return "top"; }
	/ "bottom"i _
		{ return "bottom"; }
	/ _
		{ return "bottom"; }

fieldset
	= "{" _ f:sized* "}" _
		{
			f.size = f.reduce(function (offset, field) {
				field.offset = offset;
				return offset + field.size;
			}, 0);

			return f;
		}

field
	= e:endian "signed" _ ":" _ bits:integer n:identifier
		{
			if (bits > 32) throw new Error("Integer fields may not exceed 32 bits") ;
			
			return { type: "signed", endian: e, name: n, size: bits };
		}
	/ e:endian "unsigned" _ ":" _ bits:integer n:identifier
		{
			if (bits > 32) throw new Error("Integer fields may not exceed 32 bits") ;
			
			return { type: "unsigned", endian: e, name: n, size: bits };
		}
	/ e:endian "float"  _  ":" _ bits:integer n:identifier
		{
			if (bits != 64 && bits != 32) throw new Error("IEEE Floating point may only be 32 and 64 bit") ;

			return { type: "float", endian: e, name: n, size: bits };
		}
	/ "void" _  ":" _ bits:integer
		{
			return { type: "void", size: bits };
		}
	/ "union" _ n:identifier f:fieldset
		{ 
			var size = f.reduce(function (a, b) {
				b.offset = 0;
				return Math.max(a, b.size);
			}, 0);

			return { type: "struct", name: n, fields: f, size: size };
		}
	/ "struct" _ n:identifier f:fieldset
		{
			var size = f.reduce(function (a, b) {
				return a + b.size;
			}, 0);

			return { type: "struct", name: n, fields: f, size: size };
		}

sized
	= f:field s:("[" _ s:integer "]" _ {return s; })+ (";" _)?
		{
			return s.reverse().reduce(function (f, s) {
				return { type: "array", name: f.name, count: s, field: f, size: f.size * s };
			}, f);
		}
	/ f:field (";" _)?
		{ return f; }

endian
	= "big"i _
		{ return "big"; }
	/ "little"i _
		{ return "little"; }
	/ _
		{ return "little"; }

identifier
	= a:[a-z_] b:[a-z0-9_]* _
		{ return a + b.join(''); }

integer
	= a:[1-9] b:[0-9]* _
		{ return parseInt(a + b.join(''), 10); }

_
	= ws*

ws
	= [ \n\r\t\f]
	/ "/*" (!"*/" . )* "*/"
	/ "//" (!"\n" .)*
