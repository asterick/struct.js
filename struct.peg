/**
 ** Structure handler for javascript
 **/

main
	= _ structure:top_level
{
	return function (data) {
		if (!data) { data = new ArrayBuffer(Math.ceil(structure.size/8)); }

		var dv = new DataView(data),
			u8 = new Uint8Array(data),
			s8 = new Int8Array(data),
			ta = new ArrayBuffer(8),
			tint = new Uint32Array(ta),
			tf32 = new Float32Array(ta),
			tf64 = new Float64Array(ta);

		// This is currently only little endian
		function readBits(little, bits, byteAddress, bitOffset, signed) {
			var ba = byteAddress,
				o = ["var v = 0;"];

			if (little) {
				var l = bits,
					s = 0;
					
				if (bitOffset) {
					o.push("v = u8[", ba++, "] >> ", bitOffset, ";");
					s = 8 - bitOffset;
					l -= s;
				}

				while (l >= 8) {
					o.push("v |= u8[", ba++, "] << ", s, ";");
					s += 8;
					l -= 8;
				}

				if (l > 0) {
					o.push("v |= (u8[", ba, "] & ", (1 << l) - 1,") << ", s,";");
				}
			} else {
				var s = bits,
					l = bits;

				if (bitOffset) {
					o.push("v |= (u8[", ba++, "] & ", 0xFF << bitOffset,") << ", bits - 8, ";");
					s -= (8 - bitOffset);
					l -= (8 - bitOffset);
				}

				while (l >= 8) {
					s -= 8;
					l -= 8;
					o.push("v |= u8[", ba++, "] << ", s, ";");
				}

				if (l > 0) {
					o.push("v |= u8[", ba++, "] & ", (1 << l) - 1, ";");
				}
			}

			if (bits !== 32) {
				 if (signed) {
				 	// Sign extend
				 	o.push("return v << ", 32 - bits, ">> ", 32 - bits);
				 } else {
					o.push("return v;");
				 }
			} else {
				if (signed) {
					o.push("return v;");
				} else {
					o.push("return (v & 0x80000000) ? (v + 0x100000000) : v;");
				}
			}

			return (new Function("u8", o.join(''))).bind(null, u8);
		}

		// This is currently only little endian
		function writeBits(little, bits, byteAddress, bitOffset) {
			var mask = (bits == 32) ? 0xFFFFFFFF : ((1 << bits) - 1),
				o = ["v &= ", mask, ";"],
				ba = byteAddress;
								

			if (little) {
				var l = bits,
					s = 0;

				if (bitOffset) {
					o.push("u8[",ba,"] = (u8[",ba,"] & ~(",mask << bitOffset,")) | (v << ",bitOffset,");");
					s = 8 - bitOffset;
					l -= s;
					ba++;
				}

				while (l >= 8) {
					o.push("u8[",ba++,"] = v >> ", s, ";");
					s += 8;
					l -= 8;
				}

				if (l > 0) {
					o.push("u8[",ba,"] = (u8[",ba,"] & (",0xFF << l,")) | (v >> ",s,");");
				}
			} else {
				var l = bits,
					s = bits,
					t;

				if (bitOffset) {
					t = (1 << bitOffset) - 1;

					o.push("u8[",ba,"] = (u8[",ba,"] & ", t, ") | ((v >>", bits - 8,") & ", ~t,");")

					l -= (8-bitOffset);
					s -= (8-bitOffset);
					ba++;
				}

				while (l >= 8) {
					s -= 8;
					l -= 8;
					o.push("u8[", ba++, "] = v >> ", s, ";");
				}

				if (l > 0) {
					t = (1 << l) - 1;
					o.push("u8[",ba,"] = (u8[", ba,"] & ", ~t, ") | (v & ", t,");");
				}
			}
		
			return (new Function("u8", "v", o.join(''))).bind(null, u8);
		}

		function unsigned(little, bits, byteAddress, bitOffset) {
			return {
				get: readBits(little, bits, byteAddress, bitOffset, false),
				set: writeBits(little, bits, byteAddress, bitOffset)
			};
		}

		function signed(little, bits, byteAddress, bitOffset) {
			return {
				get: readBits(little, bits, byteAddress, bitOffset, true),
				set: writeBits(little, bits, byteAddress, bitOffset)
			};
		}

		function float(little, bits, byteAddress, bitOffset) {
			if (!bitOffset) {
				switch (bits) {
				case 32:
					return {
						get: function () { return dv.getFloat32(byteAddress, little); },
						set: function (v) { dv.setFloat32(byteAddress, v, little); }
					}
				case 64:
					return {
						get: function () { return dv.getFloat64(byteAddress, little); },
						set: function (v) { dv.setFloat64(byteAddress, v, little); }
					}
				}
			}

			var rl = readBits(little, 32, byteAddress, bitOffset),
				wl = writeBits(little, 32, byteAddress, bitOffset),
				rh, wh;

			switch (bits) {
				case 32:
					return {
						get: function () {
							tint[0] = rl();
							return tf32[0]
						},
						set: function (v) {
							tf32[0] = v;
							wl(tint[0]);
						}
					};
				case 64:
					rh = readBits(little, 32, byteAddress + 4, bitOffset);
					wh = writeBits(little, 32, byteAddress + 4, bitOffset);

					return {
						get: function () {
							tint[0] = rl();
							tint[1] = rh();
							return tf64[0];
						},
						set: function (v) {
							tf64[0] = v;

							wl(tint[0]);
							wh(tint[1]);
						}
					};
			}
		}

		function fieldDefinition(field, offset) {

			if (field.count) {
				var array = {};

				for (var i = 0; i < field.count; i++) {
					var def = fieldDefinition(field.field, offset + i * field.field.size);
					if (!def) return ;
					Object.defineProperty(array, i, def);
				}

				return { value: array };
			}

			switch (field.type) {
			case 'struct':
				return { value: new Struct(data, field.fields, offset) };
			case 'unsigned':
				return unsigned(field.endian === "little", field.size, Math.floor(offset / 8), offset % 8);
			case 'signed':
				return signed(field.endian === "little", field.size, Math.floor(offset / 8), offset % 8);
			case 'float':
				return float(field.endian === "little", field.size, Math.floor(offset / 8), offset % 8);
			case 'union':
				var union = {};

				field.fields.forEach(function (f) {
					var def = fieldDefinition(f, field.offset);
					if (def) Object.defineProperty(union, f.name, def);
				});

				return { value: union };
			}
		}

		function Struct(data, fields, offset) {
			var that = Object.create({
				"_data": data,
				"_size": structure.size
			});

			fields.forEach(function (field) {
				if (field.type === "void") { return ; }

				var def = fieldDefinition(field, field.offset);
				if (def) Object.defineProperty(that, field.name, def);
			});

			return that;
		}

		console.log(structure.packing)

		return new Struct(data, structure.fields, 0);
	};
}

/**
 ** Grammar here
 **/

top_level
	= p:packing f:fieldset
		{ return { packing: p, fields: f, size: f.size }; }

packing
	= "topdown"i _
		{ return "topdown"; }
	/ "bottomup"i _
		{ return "bottomup"; }
	/ _
		{ return "bottomup"; }

fieldset
	= "{" _ f:sized* "}" _
		{
			f.size = f.reduce(function (offset, field) {
				field.offset = offset;
				return offset + field.size;
			}, 0);

			return f;
		}

field
	= e:endian "signed" _ ":" _ bits:integer n:identifier
		{
			if (bits > 32) throw new Error("Integer fields may not exceed 32 bits") ;
			
			return { type: "signed", endian: e, name: n, size: bits };
		}
	/ e:endian "unsigned" _ ":" _ bits:integer n:identifier
		{
			if (bits > 32) throw new Error("Integer fields may not exceed 32 bits") ;
			
			return { type: "unsigned", endian: e, name: n, size: bits };
		}
	/ e:endian "float"  _  ":" _ bits:integer n:identifier
		{
			if (bits != 64 && bits != 32) throw new Error("IEEE Floating point may only be 32 and 64 bit") ;

			return { type: "float", endian: e, name: n, size: bits };
		}
	/ "void" _  ":" _ bits:integer
		{
			return { type: "void", size: bits };
		}
	/ "union" _ n:identifier f:fieldset
		{ 
			var size = f.reduce(function (a, b) {
				return Math.max(a, b.size);
			}, 0);

			return { type: "union", name: n, fields: f, size: size };
		}
	/ "struct" _ n:identifier f:fieldset
		{
			var size = f.reduce(function (a, b) {
				return a + b.size;
			}, 0);

			return { type: "struct", name: n, fields: f, size: size };
		}

sized
	= f:field s:("[" _ s:integer "]" _ {return s; })+ (";" _)?
		{
			return s.reverse().reduce(function (f, s) {
				return { type: "array", name: f.name, count: s, field: f, size: f.size * s };
			}, f);
		}
	/ f:field (";" _)?
		{ return f; }

endian
	= "big"i _
		{ return "big"; }
	/ "little"i _
		{ return "little"; }
	/ _
		{ return "little"; }

identifier
	= a:[a-z_] b:[a-z0-9_]* _
		{ return a + b.join(''); }

integer
	= a:[1-9] b:[0-9]* _
		{ return parseInt(a + b.join(''), 10); }
	/ "0" _
		{ return 0; }

_
	= ws*

ws
	= [ \n\r\t\f]
	/ "/*" (!"*/" . )* "*/"
	/ "//" (!"\n" .)*
