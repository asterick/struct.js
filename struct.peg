/**
 ** Structure handler for javascript
 **/

main
	= _ s:fieldset
{
	return function (data) {
		if (!data) { data = new ArrayBuffer(Math.ceil(s.size/8)); }

		var dv = new DataView(data),
			u8 = new Uint8Array(data),
			s8 = new Int8Array(data),
			ta = new ArrayBuffer(8),
			tint = new Uint32Array(ta),
			tf32 = new Float32Array(ta),
			tf64 = new Float64Array(ta);

		// This is currently only little endian
		function readBits(little, bits, byteAddress, bitOffset, signed) {
			var ba = byteAddress,
				o = ["var v = 0;"];

			debugger ;

			if (little) {
				var l = bits,
					s = 0;
					
				if (bitOffset) {
					o.push("v = u8[", ba++, "] >> ", bitOffset, ";");
					s = 8 - bitOffset;
					l -= s;
				}

				while (l > 0) {
					o.push("v |= u8[", ba++, "] << ", s, ";");
					s += 8;
					l -= 8;
				}

				if (bits !== 32) {
					 if (signed) {
					 	// Sign extend
					 	o.push("return v << ", 32 - bits, ">> ", 32 - bits);
					 } else {
						o.push("return v & ((1 << ", bits, ") - 1)");
					 }
				} else {
					if (signed) {
						o.push("return v;");
					} else {
						o.push("return (v & 0x80000000) ? (v + 0x100000000) : v;");
					}
				}
			} else {
				var l = bits,
					s = 0;
					
				if (bitOffset) {
					o.push("v = u8[", ba++, "] >> ", bitOffset, ";");
					s = 8 - bitOffset;
					l -= s;
				}

				while (l > 0) {
					o.push("v |= u8[", ba++, "] << ", s, ";");
					s += 8;
					l -= 8;
				}

				if (bits !== 32) {
					 if (signed) {
					 	// Sign extend
					 	o.push("return v << ", 32 - bits, ">> ", 32 - bits);
					 } else {
						o.push("return v & ((1 << ", bits, ") - 1)");
					 }
				} else {
					if (signed) {
						o.push("return v;");
					} else {
						o.push("return (v & 0x80000000) ? (v + 0x100000000) : v;");
					}
				}
			}

			return (new Function("u8", o.join(''))).bind(null, u8);
		}

		// This is currently only little endian
		function writeBits(little, bits, byteAddress, bitOffset) {
			var ba = byteAddress,
				mask = (bits == 32) ? 0xFFFFFFFF : ((1 << bits) - 1),
				l = bits,
				s = 0,
				// Trim off unused bits
				o = ["v &= ", mask, ";"];

			if (!little) { throw new Error("Big-endian on unaligned values unsupported"); }


			if (bitOffset) {
				o.push("u8[",ba,"] = (u8[",ba,"] & ~(",mask << bitOffset,")) | (v << ",bitOffset,");");
				s = 8 - bitOffset;
				l -= s;
				ba++;
			}

			while (l >= 8) {
				o.push("u8[",ba++,"] = v >> ", s, ";");
				s += 8;
				l -= 8;
			}

			if (l > 0) {
				o.push("u8[",ba,"] = (u8[",ba,"] & (",0xFF << l,")) | (v >> ",s,");");
			}
		
			return (new Function("u8", "v", o.join(''))).bind(null, u8);
		}

		function unsigned(little, bits, byteAddress, bitOffset) {
			if (!bitOffset) {
				switch (bits) {
				case 8:
					return {
						get: function () { return u8[byteAddress]; },
						set: function (v) { u8[byteAddress] = v; }
					}
				case 16:
					return {
						get: function () { return dv.getUint16(byteAddress, little); },
						set: function (v) { dv.setUint16(byteAddress, v, little); }
					}
				case 32:
					return {
						get: function () { return dv.getUint32(byteAddress, little); },
						set: function (v) { dv.setUint32(byteAddress, v, little); }
					}
				}
			}

			return {
				get: readBits(little, bits, byteAddress, bitOffset, false),
				set: writeBits(little, bits, byteAddress, bitOffset)
			};
		}

		function signed(little, bits, byteAddress, bitOffset) {
			if (!bitOffset) {
				switch (bits) {
				case 8:
					return {
						get: function () { return s8[byteAddress]; },
						set: function (v) { s8[byteAddress] = v; }
					}
				case 16:
					return {
						get: function () { return dv.getInt16(byteAddress, little); },
						set: function (v) { dv.setInt16(byteAddress, v, little); }
					}
				case 32:
					return {
						get: function () { return dv.getInt32(byteAddress, little); },
						set: function (v) { dv.setInt32(byteAddress, v, little); }
					}
				}
			}

			return {
				get: readBits(little, bits, byteAddress, bitOffset, true),
				set: writeBits(little, bits, byteAddress, bitOffset)
			};

			return o;
		}

		function float(little, bits, byteAddress, bitOffset) {
			if (!bitOffset) {
				switch (bits) {
				case 32:
					return {
						get: function () { return dv.getFloat32(byteAddress, little); },
						set: function (v) { dv.setFloat32(byteAddress, v, little); }
					}
				case 64:
					return {
						get: function () { return dv.getFloat64(byteAddress, little); },
						set: function (v) { dv.setFloat64(byteAddress, v, little); }
					}
				}
			}

			var rl = readBits(little, 32, byteAddress, bitOffset),
				wl = writeBits(little, 32, byteAddress, bitOffset),
				rh, wh;

			switch (bits) {
				case 32:
					return {
						get: function () {
							tint[0] = rl();
							return tf32[0]
						},
						set: function (v) {
							tf32[0] = v;
							wl(tint[0]);
						}
					};
				case 64:
					rh = readBits(little, 32, byteAddress + 4, bitOffset);
					wh = writeBits(little, 32, byteAddress + 4, bitOffset);

					return {
						get: function () {
							tint[0] = rl();
							tint[1] = rh();
							return tf64[0];
						},
						set: function (v) {
							tf64[0] = v;

							wl(tint[0]);
							wh(tint[1]);
						}
					};
			}
		}

		function fieldDefinition(field, offset) {

			if (field.count) {
				var array = {};

				for (var i = 0; i < field.count; i++) {
					var def = fieldDefinition(field.field, offset + i * field.field.size);
					if (!def) return ;
					Object.defineProperty(array, i, def);
				}

				return { value: array };
			}

			switch (field.type) {
			case 'struct':
				return { value: new Struct(data, field.fields, offset) };
			case 'unsigned':
				return unsigned(field.endian === "little", field.size, Math.floor(offset / 8), offset % 8);
			case 'signed':
				return signed(field.endian === "little", field.size, Math.floor(offset / 8), offset % 8);
			case 'float':
				return float(field.endian === "little", field.size, Math.floor(offset / 8), offset % 8);
			case 'union':
				var union = {};

				field.fields.forEach(function (f) {
					var def = fieldDefinition(f, field.offset);
					if (def) Object.defineProperty(union, f.name, def);
				});

				return { value: union };
			}
		}

		function Struct(data, fields, offset) {
			var that = Object.create({
				_data: data,
				_size: s.size
			});

			fields.forEach(function (field) {
				if (field.type === "void") { return ; }

				var def = fieldDefinition(field, field.offset);
				if (def) Object.defineProperty(that, field.name, def);
			});

			return that;
		}

		return new Struct(data, s, 0);
	};
}

/**
 ** Grammar here
 **/

fieldset
	= "{" _ f:sized* "}" _
		{
			f.size = f.reduce(function (offset, field) {
				field.offset = offset;
				return offset + field.size;
			}, 0);

			return f;
		}

field
	= e:endian "signed" _ ":" _ bits:integer n:identifier
		{
			if (bits > 32) throw new Error("Integer fields may not exceed 32 bits") ;
			
			return { type: "signed", endian: e, name: n, size: bits };
		}
	/ e:endian "unsigned" _ ":" _ bits:integer n:identifier
		{
			if (bits > 32) throw new Error("Integer fields may not exceed 32 bits") ;
			
			return { type: "unsigned", endian: e, name: n, size: bits };
		}
	/ e:endian "float"  _  ":" _ bits:integer n:identifier
		{
			if (bits != 64 && bits != 32) throw new Error("IEEE Floating point may only be 32 and 64 bit") ;

			return { type: "float", endian: e, name: n, size: bits };
		}
	/ "void" _  ":" _ bits:integer
		{
			return { type: "void", size: bits };
		}
	/ "union" _ n:identifier f:fieldset
		{ 
			var size = f.reduce(function (a, b) {
				return Math.max(a, b.size);
			}, 0);

			return { type: "union", name: n, fields: f, size: size };
		}
	/ "struct" _ n:identifier f:fieldset
		{
			var size = f.reduce(function (a, b) {
				return a + b.size;
			}, 0);

			return { type: "struct", name: n, fields: f, size: size };
		}

sized
	= f:field s:("[" _ s:integer "]" _ {return s; })+ (";" _)?
		{
			return s.reverse().reduce(function (f, s) {
				return { type: "array", name: f.name, count: s, field: f, size: f.size * s };
			}, f);
		}
	/ f:field (";" _)?
		{ return f; }

endian
	= "big"i _
		{ return "big"; }
	/ "little"i _
		{ return "little"; }
	/ _
		{ return "little"; }

identifier
	= a:[a-z_] b:[a-z0-9_]* _
		{ return a + b.join(''); }

integer
	= a:[1-9] b:[0-9]* _
		{ return parseInt(a + b.join(''), 10); }
	/ "0" _
		{ return 0; }

_
	= ws*

ws
	= [ \n\r\t\f]
	/ "/*" (!"*/" . )* "*/"
	/ "//" (!"\n" .)*
